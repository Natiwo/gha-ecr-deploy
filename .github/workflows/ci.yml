# CI Pipeline - Build, Test, Security
# Artifact caching enabled for CD reuse
name: CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:

concurrency:
  group: ci-${{ github.ref }}
  cancel-in-progress: true

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: your-org/your-repo  # Change to your repo (lowercase)

jobs:
  quality:
    name: Quality Gates
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Lint Dockerfile
        uses: hadolint/hadolint-action@v3.1.0
        with:
          dockerfile: Dockerfile
          ignore: DL3008,DL3013,DL3015,DL4006
          failure-threshold: error

      - name: Lint Shell Scripts
        uses: ludeeus/action-shellcheck@master
        with:
          scandir: './scripts'
          severity: warning

      - name: Lint YAML
        uses: ibiqlik/action-yamllint@v3
        with:
          file_or_dir: .
          config_data: |
            extends: relaxed
            rules:
              line-length:
                max: 120

  security:
    name: Security Scan
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Secret Scan
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          scanners: 'secret'
          severity: 'CRITICAL,HIGH,MEDIUM'
          exit-code: '1'

      - name: Vulnerability Scan
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          scanners: 'vuln,misconfig'
          severity: 'CRITICAL,HIGH'
          exit-code: '1'

  build:
    name: Build ${{ matrix.target }}
    runs-on: ubuntu-latest
    needs: [quality, security]
    strategy:
      fail-fast: false
      matrix:
        target: [minimal, runtime]  # Customize for your Dockerfile
    outputs:
      image-id: ${{ steps.export.outputs.image-id }}
    steps:
      - uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Generate metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=sha,prefix=,suffix=-${{ matrix.target }}
            type=ref,event=branch,suffix=-${{ matrix.target }}
            type=ref,event=pr,suffix=-${{ matrix.target }}

      - name: Build image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: Dockerfile
          target: ${{ matrix.target }}
          platforms: linux/amd64
          load: true
          tags: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}-${{ matrix.target }}
            ci-test-${{ matrix.target }}:latest
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha,scope=${{ matrix.target }}
          cache-to: type=gha,mode=max,scope=${{ matrix.target }}

      - name: Export image info
        id: export
        run: |
          IMAGE_ID=$(docker images ci-test-${{ matrix.target }}:latest --format '{{.ID}}')
          echo "image-id=$IMAGE_ID" >> $GITHUB_OUTPUT

      - name: Save image artifact
        run: docker save ci-test-${{ matrix.target }}:latest | gzip > /tmp/image-${{ matrix.target }}.tar.gz

      - name: Upload image artifact
        uses: actions/upload-artifact@v4
        with:
          name: docker-image-${{ matrix.target }}
          path: /tmp/image-${{ matrix.target }}.tar.gz
          retention-days: 1

  test:
    name: Test ${{ matrix.target }}
    runs-on: ubuntu-latest
    needs: build
    strategy:
      fail-fast: false
      matrix:
        target: [minimal, runtime]
    steps:
      - uses: actions/checkout@v4

      - name: Download image artifact
        uses: actions/download-artifact@v4
        with:
          name: docker-image-${{ matrix.target }}
          path: /tmp

      - name: Load image
        run: gunzip -c /tmp/image-${{ matrix.target }}.tar.gz | docker load

      - name: Test container starts
        run: docker run --rm ci-test-${{ matrix.target }}:latest echo "OK"

      # Customize these tests for your application
      - name: Test application
        run: |
          docker run --rm ci-test-${{ matrix.target }}:latest bash -c '
            set -e
            # Add your tests here
            echo "Tests passed"
          '

  summary:
    name: CI Summary
    runs-on: ubuntu-latest
    needs: [quality, security, build, test]
    if: always()
    outputs:
      success: ${{ steps.check.outputs.success }}
    steps:
      - name: Check results
        id: check
        run: |
          echo "## CI Results" >> $GITHUB_STEP_SUMMARY
          echo "| Job | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-----|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Quality | ${{ needs.quality.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Security | ${{ needs.security.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Build | ${{ needs.build.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Test | ${{ needs.test.result }} |" >> $GITHUB_STEP_SUMMARY

          if [ "${{ needs.quality.result }}" != "success" ] || \
             [ "${{ needs.security.result }}" != "success" ] || \
             [ "${{ needs.build.result }}" != "success" ] || \
             [ "${{ needs.test.result }}" != "success" ]; then
            echo "success=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          echo "success=true" >> $GITHUB_OUTPUT
